# Phase 0 — Foundation

## Phase Overview

**Goal**: Establish the project scaffold, Copilot SDK integration, all file parsers, the SongState schema, and the core tool registration infrastructure. After Phase 0, the system can read every asset type in the MPC Beats workspace, maintain a conversation session with SongState tracking, and respond to basic music queries.

**Dependencies**: None (this is the root phase)

**Exports consumed by**: Every subsequent phase (C1-C5, C7 contracts, tool registration patterns, session lifecycle)

---

## SDK Integration Points

| SDK Feature | Phase 0 Usage |
|---|---|
| `CopilotClient` | Spawn/connect to CLI server; configure BYOK if user has custom API key |
| `CopilotSession.create()` | Initialize session with system message, tools, hooks, skill directories |
| `defineTool()` | Register all read/parse tools (5-6 tools) |
| `systemMessage` | MUSE persona prompt — musical omniscience, personality, MPC Beats awareness |
| `hooks.onSessionStart` | Scan workspace for assets, build asset manifest, inject L0 context |
| `hooks.onSessionEnd` | Persist SongState to `output/<session>/song-state.json` |
| `hooks.onPostToolUse` | Update SongState after any state-modifying tool call |
| `hooks.onErrorOccurred` | Log errors, suggest manual fallback paths |
| `infiniteSessions` | Enable with `backgroundCompactionThreshold: 0.80`, `bufferExhaustionThreshold: 0.95` |
| `skillDirectories` | Point to `./skills/` — even if empty initially, the structure is established |
| Permission handler | Require approval for file writes to MPC Beats directories |

---

## Task Breakdown

### Task 0.1 — Project Scaffold & SDK Bootstrap

**Description**: Initialize the Node.js/TypeScript project, install `@github/copilot-sdk`, configure `tsconfig.json`, set up directory structure, and create the entry point that spawns a `CopilotClient` and creates a session.

**Input**: None (greenfield)

**Output**:
- `package.json` with `@github/copilot-sdk`, `zod`, `typescript`, `vitest` dependencies
- `tsconfig.json` (strict mode, ESM, path aliases)
- `src/index.ts` — entry point: creates `CopilotClient`, `CopilotSession`
- Directory skeleton: `src/`, `skills/`, `data/`, `output/`, `tests/`

**Implementation Hints**:
- Use `moduleResolution: "bundler"` for SDK compatibility
- Path alias `@muse/` → `src/`
- Vitest for testing (fast, ESM-native, mocking built-in)
- Entry point should accept optional CLI args: `--model`, `--provider`, `--mpc-path`
- `--mpc-path` defaults to scanning for standard MPC Beats install paths

**Testing**: Verify session creates successfully, `systemMessage` is set, exit cleanly.

**Complexity**: S

---

### Task 0.2 — System Message Architecture

**Description**: Design and implement the MUSE system prompt that establishes the AI's musical personality, knowledge base, and behavioral constraints. The prompt must be dynamically composed from a static persona template + injected workspace context.

**Input**:
- Static persona template (markdown)
- Asset manifest (generated by workspace scanner, Task 0.3)
- Active SongState L0 summary (if resuming)

**Output**:
- `src/prompts/system-message.ts` — function `buildSystemMessage(manifest, songState?): string`
- `skills/core/SKILL.md` — the MUSE persona skill file

**Implementation Hints**:
- System message structure:
  1. **Identity** (~100 tokens): "You are MUSE, a musically omniscient AI..."
  2. **Capabilities** (~200 tokens): Available tool descriptions, what file types you understand
  3. **Workspace Context** (~150 tokens): "This workspace contains 47 progressions, 80 arp patterns, 297 TubeSynth presets..."
  4. **Active State** (~100 tokens): Current SongState L0 if in-progress
  5. **Behavioral Rules** (~150 tokens): Always explain musical reasoning, use tool calls for data access, never hallucinate preset names
- Use `mode: "append"` so SDK's base system prompt is preserved
- Template literals with tagged template function for clean composition
- Total budget: ~700 tokens for system message

**Testing**: Snapshot test system message for known inputs. Verify token count stays under budget. Test with/without active SongState.

**Complexity**: M

---

### Task 0.3 — Workspace Asset Scanner

**Description**: Scan the MPC Beats installation directory to discover all available assets. Build an `AssetManifest` that inventories progressions, arp patterns, controller maps, synth presets, and effects.

**Input**:
- MPC Beats installation path (e.g., `C:\dev\MPC Beats`)

**Output**:
```typescript
interface AssetManifest {
  basePath: string;
  scannedAt: string;
  progressions: { path: string; name: string }[];    // 47 items
  arpPatterns: { path: string; name: string; category: string; subCategory: string }[];  // 80 items
  controllerMaps: { path: string; manufacturer: string; model: string }[];  // 67 items
  synthEngines: SynthEngine[];
  effects: EffectPlugin[];
}

interface SynthEngine {
  name: string;               // "TubeSynth"
  path: string;
  presets: { index: number; name: string; category: string; path: string }[];
}

interface EffectPlugin {
  name: string;               // "AIR Reverb"
  manufacturer: string;       // "AIR Music Technology" | "Akai Professional"
  type: "insert" | "send";    // inferred from name patterns
}
```

**Implementation Hints**:
- Arp pattern naming convention: `{index}-{category}-{subCategory} {variant}.mid` — parse with regex
- Synth preset naming: `{index}-{category}-{name}.xpl` — derive category from prefix
- Controller map: parse XML for `Manufacturer` attribute and `<Input>` port name
- Effects: directory name holds the full identifier, e.g. `"Akai Professional - MPC - Compressor Opto"` → extract manufacturer, strip "MPC -" prefix
- Cache manifest to `data/asset-manifest.json` with timestamp; re-scan if stale (>24h) or on demand
- Handle missing directories gracefully (user may have partial install)

**Testing**: Run against actual MPC Beats directory. Verify counts: 47 progressions, 80 arp patterns (check full listing), 67 controller maps. Verify TubeSynth has 297 presets in 7 categories.

**Complexity**: M

---

### Task 0.4 — Progression File Parser

**Description**: Parse `.progression` JSON files into `RawProgression` (C1 contract). This is the foundational parser — all harmonic analysis builds on this.

**Input**: File path to a `.progression` file

**Output**: `RawProgression` object (Contract C1)

**Implementation Hints**:
- Files are well-formed JSON (verified by inspecting actual files)
- Zod schema for runtime validation:
  ```typescript
  const RawChordSchema = z.object({
    name: z.string(),
    role: z.enum(["Root", "Normal"]),
    notes: z.array(z.number().int().min(0).max(127)),
  });
  const RawProgressionSchema = z.object({
    progression: z.object({
      name: z.string(),
      rootNote: z.string(),
      scale: z.string(),
      recordingOctave: z.number(),
      chords: z.array(RawChordSchema),
    }),
  });
  ```
- Parse genre from name field: `"Gospel-Godly"` → genre "Gospel", name "Godly"
- Handle edge cases: chord names with slashes (inversions), variable note counts (4-9 notes observed)
- Return both raw parse result and any parse warnings

**Testing**: Parse all 47 progression files. Zero failures. Spot-check: Godly has 16 chords, Neo Soul 1 has 16 chords. Verify MIDI note ranges are 38-88 (observed range).

**Complexity**: S

---

### Task 0.5 — MIDI File Parser (Arp Patterns)

**Description**: Parse `.mid` (Standard MIDI File) into `ParsedArpPattern` (C2 contract). Extract note events, timing, velocity, and compute rhythmic analysis.

**Input**: File path to a `.mid` file

**Output**: `ParsedArpPattern` object (Contract C2)

**Implementation Hints**:
- Use `midi-file` npm package (pure JS, no native deps) for SMF parsing
- MIDI files use delta-time in ticks; need header's `ticksPerBeat` to convert to musical time
- Extract from filename: index, category, subCategory using regex on the naming convention
- Analysis computation:
  - **Density**: `noteCount / durationBeats`
  - **Pitch range**: `max(notes) - min(notes)` in semitones
  - **Velocity stats**: min, max, mean, stddev
  - **Rhythmic grid**: GCD of all note-on ticks → smallest subdivision
  - **Swing**: Compare even vs odd 8th-note positions; ratio deviation from 50/50
  - **Interval distribution**: Histogram of pitch intervals between successive notes
- Category mapping:
  - Indices 0-37: "Chord" (from file listing)
  - Indices 38-55: "Melodic"
  - Indices 56-79+: "Bass"

**Testing**: Parse all 80 arp pattern files. Zero failures. Verify category assignment matches directory listing. Spot-check density: Chord patterns should have lower density than Bass patterns. Verify no negative durations.

**Complexity**: M

---

### Task 0.6 — Controller Map Parser (.xmm)

**Description**: Parse `.xmm` XML files into `ParsedControllerMap` (C3 contract). Extract device info, MIDI preamble, and all Target_control ↔ MIDI mappings.

**Input**: File path to a `.xmm` file

**Output**: `ParsedControllerMap` object (Contract C3)

**Implementation Hints**:
- Use `fast-xml-parser` npm package (fast, no native deps)
- XML structure (from real file analysis):
  ```xml
  <MidiLearnMap_ Manufacturer="Akai" Version="0.3">
    <device>
      <Input WindowsPortName="MPK mini 3"/>
      <Output WindowsPortName="MPK mini 3"/>
    </device>
    <pairing>
      <Target_ Target_control="0"/>
      <Mapping_ Mapping_type="1" Mapping_channel="10" Mapping_data1="36" Mapping_control="4"/>
    </pairing>
  </MidiLearnMap_>
  ```
- Mapping_type values: 0 = unmapped, 1 = Note On/Off, 2 = CC
- Mapping_control values: 4 = pad/key (button), 7 = knob/slider (continuous)
- Target_control is the MPC internal function index (opaque — research in Phase 7)
- Many Target_controls map to type=0 (unmapped) — these represent unused potential
- Collect statistics: how many pads, knobs, sliders per controller

**Testing**: Parse all 67 controller maps. Verify manufacturer extraction. Verify Akai MPK mini 3 has 16 pads (Target 0-15, type=1, channel=10, notes 36-51) and 8 knobs (Target 24-31, type=2, channel=1). Count total unique Target_control indices across all files.

**Complexity**: M

---

### Task 0.7 — Synth Preset Cataloger

**Description**: Scan synth preset directories and build a structured catalog of all available presets with category, engine, and index. Does NOT parse the binary `.xpl` files — only extracts metadata from filenames and directory structure.

**Input**: Synth directory path (e.g. `Synths/AIR Music Technology - MPC - TubeSynth/Presets/`)

**Output**:
```typescript
interface PresetCatalog {
  engines: {
    name: string;           // "TubeSynth"
    manufacturer: string;   // "AIR Music Technology"
    type: "synth" | "effect" | "drum";
    presets: PresetEntry[];
  }[];
}

interface PresetEntry {
  index: number;
  name: string;             // "Warm Pad"
  category: string;         // "Pad"
  fullName: string;         // "169-Pad-Warm Pad"
  path: string;
}
```

**Implementation Hints**:
- Filename pattern: `{3-digit index}-{Category}-{Name}.xpl`
- Special case: `000-Rich Swell.xpl` has no category prefix, `297-Init.xpl` is a template
- DrumSynth has 10 sub-variants (Kick, Snare, HiHat, etc.) — each is a separate engine
- VST instruments (DB-33, Hybrid, Loom, etc.) have different directory structures
- Effects should be cataloged separately from synths — they're in different parent directories
- Known categories from TubeSynth: Synth (44), Lead (50), Pluck (40), Pad (68), Bass (65), Organ (7), FX (23)

**Testing**: Verify TubeSynth catalog has exactly 298 entries (297 + Init). Verify category counts match blueprint numbers. Verify all engines are discovered.

**Complexity**: S

---

### Task 0.8 — SongState Schema & Persistence

**Description**: Implement the `SongState` schema (Contract C4), its JSON serialization/deserialization, the hierarchical compression levels (L0-L3), and the persistence layer.

**Input**: N/A (schema definition)

**Output**:
- `src/schemas/song-state.ts` — Zod schema + TypeScript types
- `src/state/song-state-manager.ts` — CRUD operations, compression, persistence
- `src/state/compressor.ts` — L0/L1/L2/L3 compression functions

**Implementation Hints**:
- Zod schemas for all SongState sub-types (runtime validation on load)
- Compression functions:
  - `compressL0(state): string` — "8 tracks, Eb minor, 130 BPM, neo-soul/ambient" (~100 tokens)
  - `compressL1(state): object` — names, roles, presets, section boundaries, chord symbols (~500 tokens)
  - `compressL2(state): object` — full MIDI notes, exact parameters, effect chains (~3000 tokens)
  - `compressL3(state): object` — full history with before/after values (variable)
- Persistence to `output/<session-id>/song-state.json`
- Session ID generation: timestamp + 4-char random suffix
- Implement `applyChange(state, change): SongState` — immutable update with history entry
- Implement `undo(state, n?): SongState` — replay history minus last N changes

**Testing**: Round-trip serialize/deserialize. Verify compression levels produce expected token counts (use tiktoken or char-count heuristic). Test undo: apply 3 changes, undo 2, verify state matches after 1st change.

**Complexity**: L

---

### Task 0.9 — Tool Registration Infrastructure

**Description**: Create the tool registration framework that wraps `defineTool()` with MUSE conventions: consistent error handling, SongState updates, logging, and Zod schema patterns.

**Input**: N/A (framework design)

**Output**:
- `src/tools/define-muse-tool.ts` — wrapper around SDK's `defineTool`
- `src/tools/registry.ts` — central tool registry for discovery and documentation

**Implementation Hints**:
- Wrapper pattern:
  ```typescript
  function defineMuseTool<T extends z.ZodType>(
    name: string,
    config: {
      description: string;
      parameters: T;
      category: "read" | "generate" | "analyze" | "control";
      modifiesSongState: boolean;
      handler: (params: z.infer<T>, context: MuseToolContext) => Promise<unknown>;
    }
  ): Tool
  ```
- `MuseToolContext` provides: current SongState, asset manifest, logger, session metadata
- All tool handlers wrapped in try/catch with structured error responses
- If `modifiesSongState: true`, the `onPostToolUse` hook triggers SongState update
- Registry enables: listing all tools, filtering by category, generating tool documentation for system prompt

**Testing**: Register a mock tool, invoke it, verify error handling wraps exceptions. Verify SongState update triggers for state-modifying tools. Verify registry correctly lists tools by category.

**Complexity**: M

---

### Task 0.10 — Read Tools: Initial Tool Set

**Description**: Register the first set of read-only tools using the infrastructure from Task 0.9 and the parsers from Tasks 0.4-0.7.

**Tools to register**:

| Tool Name | Zod Parameters | Returns | Parser Used |
|---|---|---|---|
| `read_progression` | `{ filePath: z.string() }` | `EnrichedProgression` (basic — full enrichment in Phase 1) | Task 0.4 |
| `read_arp_pattern` | `{ filePath: z.string() }` | `ParsedArpPattern` | Task 0.5 |
| `read_controller_map` | `{ filePath: z.string() }` | `ParsedControllerMap` | Task 0.6 |
| `list_presets` | `{ engine: z.string().optional() }` | `PresetCatalog` (filtered) | Task 0.7 |
| `list_assets` | `{ type: z.enum(["progression","arp","controller","preset"]).optional() }` | `AssetManifest` (filtered) | Task 0.3 |

**Implementation Hints**:
- Each tool should return richly formatted text (not raw JSON) so the LLM can reason about it musically
- `read_progression` returns chord names + MIDI notes + basic analysis (roman numerals wait for Phase 1)
- `read_arp_pattern` returns note count, density, velocity range, pitch range
- `list_assets` is a discovery tool — the LLM uses this to find assets before calling specific read tools
- `list_presets` with no engine arg returns a summary of all engines; with engine arg returns full preset list

**Testing**: End-to-end: create session, send user message "What progressions are available?", verify LLM calls `list_assets`, verify response includes progression names. Repeat for each tool.

**Complexity**: M

---

### Task 0.11 — Session Hooks Implementation

**Description**: Implement the session lifecycle hooks that maintain conversational state, workspace awareness, and session persistence.

**Hooks to implement**:

| Hook | Purpose |
|---|---|
| `onSessionStart` | Scan workspace, build manifest, create/load SongState, inject L0 context |
| `onSessionEnd` | Persist SongState to disk, log session summary |
| `onPostToolUse` | If tool modifies SongState, update state + append history entry |
| `onPreToolUse` | Log tool invocation; check permissions for file-write tools |
| `onErrorOccurred` | Log error, format user-friendly message, suggest recovery |

**Implementation Hints**:
- `onSessionStart`:
  - Run workspace scanner (Task 0.3)
  - Check for existing SongState in `output/` — offer to resume if found
  - Return `{ additionalContext: compressL0(songState) + manifestSummary }`
- `onPostToolUse`:
  - Examine tool name and result
  - If tool is in `stateModifyingTools` set, call `songStateManager.applyChange()`
  - For infinite sessions, check if SongState compression should increase
- `onPreToolUse`:
  - For `generate_*` tools that write files: return `{ permissionDecision: "allow" }` (or "ask" for destructive ops)
- `onErrorOccurred`:
  - Map common errors to friendly messages: file not found → "That preset file doesn't exist. Try `list_presets` to see available presets."

**Testing**: Start session with hook, verify workspace scanned. Use a state-modifying tool, verify SongState updated. Trigger error condition, verify user-friendly message returned.

**Complexity**: L

---

### Task 0.12 — Configuration & CLI Interface

**Description**: Create the CLI interface for launching MUSE, handling configuration (MPC path, model, provider), and supporting both interactive and programmatic modes.

**Input**: CLI arguments / config file

**Output**:
- `src/cli.ts` — CLI entry point with argument parsing
- `muse.config.json` — user configuration file (optional)

**Implementation Hints**:
- CLI args (using `commander` or `yargs`):
  - `--mpc-path <path>` — MPC Beats installation directory
  - `--model <model>` — LLM model to use (default: "gpt-4o")
  - `--provider <provider>` — "copilot" (default) | "openai" | "azure" | "anthropic" | "ollama"
  - `--api-key <key>` — for BYOK providers
  - `--session <id>` — resume a specific session
  - `--output-dir <path>` — where to write generated files (default: `./output`)
  - `--verbose` — enable debug logging
- Config file resolution: CLI args > `muse.config.json` in cwd > defaults
- Auto-detect MPC Beats path on Windows: scan `C:\Program Files\Akai\MPC Beats\`, `C:\Program Files (x86)\...`, and user-specified paths
- Interactive mode: starts a REPL-like loop (session.sendMessage → print response)
- Programmatic mode: accepts stdin piped messages (for integration with editors)

**Testing**: Test CLI arg parsing. Test config file loading with overrides. Test MPC path auto-detection (mock filesystem). Test session resume from existing output directory.

**Complexity**: S

---

## Modular Boundaries

| Can develop independently | Requires sequence |
|---|---|
| Tasks 0.1, 0.2 (scaffold, prompts) | 0.9 requires 0.1 |
| Tasks 0.3, 0.4, 0.5, 0.6, 0.7 (all parsers — fully parallel) | 0.10 requires 0.4-0.7 + 0.9 |
| Task 0.8 (SongState schema) | 0.11 requires 0.8 + 0.9 |
| Task 0.12 (CLI) | Requires 0.1 + 0.11 for full integration |

**Recommended execution order**:
1. 0.1 (scaffold) — blocks everything
2. 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8 — all in parallel
3. 0.9 (tool infra)
4. 0.10 (register tools), 0.11 (hooks) — parallel
5. 0.12 (CLI) — integration

---

## Cross-Phase Exports

| Export | Consumer Phases |
|---|---|
| `RawProgression`, `RawChord` types | 1, 2, 3, 6 |
| `ParsedArpPattern`, `MidiNoteEvent` types | 2, 3, 6 |
| `ParsedControllerMap`, `ControlPairing` types | 5, 7 |
| `PresetCatalog`, `PresetEntry` types | 2, 4, 6 |
| `AssetManifest` type | 2, 6 |
| `SongState` and all sub-types | ALL |
| `defineMuseTool` wrapper | ALL (every phase registers tools) |
| `SongStateManager` class | ALL |
| `buildSystemMessage` function | 6, 9 (to extend the prompt) |

---

## Risk Flags

| Risk | Severity | Description |
|---|---|---|
| SDK API stability | Medium | `@github/copilot-sdk` is new; API may change between versions. Pin exact version. |
| `customAgents` routing accuracy | Medium | `infer: true` depends on the LLM correctly routing queries. May need fallback logic. |
| `.xpl` binary format | Low (Phase 0) | We explicitly do NOT parse .xpl in Phase 0. This becomes a risk in Phase 4. |
| Large controller map count | Low | 67 files × XML parsing = ~2-3 seconds cold scan. Cache aggressively. |
| Windows path handling | Low | MPC Beats is Windows-only; all path handling must use `path.win32` or normalize consistently. |
| MIDI file format variations | Medium | Some .mid files may use Format 0 vs Format 1; the parser must handle both. |
