"""
Base Agent Interfaces and Data Structures

This module defines the core interfaces and data structures for the
agent-based performer architecture:

- AgentRole: Enum of musical roles agents can fulfill
- IPerformerAgent: Abstract interface for all performer agents
- PerformanceResult: Output from a performer agent

Design Philosophy:
    Each performer agent is autonomous and responsible for generating
    notes for their musical role, reacting to a shared PerformanceContext.
    This mirrors how real musicians in a band communicate and react to
    each other and the conductor.

Stage 1: Offline implementations wrap existing procedural methods
Stage 2: API-backed implementations call Copilot/Gemini
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from .context import PerformanceContext
    from .personality import AgentPersonality
    from ..midi_generator import NoteEvent
    from ..arranger import SongSection


class AgentRole(Enum):
    """
    Musical roles that agents can fulfill.
    
    Each role represents a distinct musical function in the ensemble.
    An agent can only fulfill one role at a time, but the system can
    have multiple agents of the same role (e.g., multiple string agents).
    """
    DRUMS = "drums"           # Rhythm section - kick, snare, hi-hats, cymbals
    BASS = "bass"             # Low-frequency foundation - 808s, bass guitar, synth bass
    KEYS = "keys"             # Chordal/harmonic - piano, rhodes, organ, pads
    LEAD = "lead"             # Melodic lead - synth leads, guitar leads
    PAD = "pad"               # Atmospheric/ambient - pads, textures, drones
    STRINGS = "strings"       # Orchestral strings - violin, viola, cello, contrabass
    BRASS = "brass"           # Brass section - trumpet, trombone, horn, tuba
    PERCUSSION = "percussion" # Non-kit percussion - congas, shakers, tambourine
    FX = "fx"                 # Sound effects and one-shots
    SECTION = "section"       # Meta-agent coordinating sub-performers


@dataclass
class PerformanceResult:
    """
    Output from a performer agent.
    
    Contains the generated notes along with metadata about the
    performance for debugging, learning, and inter-agent communication.
    
    Attributes:
        notes: List of NoteEvent objects generated by the agent
        agent_role: The role this agent fulfilled
        agent_name: Human-readable name of this agent instance
        personality_applied: The personality configuration used
        decisions_made: Log of creative choices made during generation
        patterns_used: Names of patterns used (for analytics)
        fill_locations: Tick positions where fills were inserted
    """
    notes: List['NoteEvent'] = field(default_factory=list)
    agent_role: AgentRole = AgentRole.DRUMS
    agent_name: str = "Unknown Agent"
    personality_applied: Optional['AgentPersonality'] = None
    decisions_made: List[str] = field(default_factory=list)
    patterns_used: List[str] = field(default_factory=list)
    fill_locations: List[int] = field(default_factory=list)
    
    def __post_init__(self):
        """Ensure mutable defaults are properly initialized."""
        if self.notes is None:
            self.notes = []
        if self.decisions_made is None:
            self.decisions_made = []
        if self.patterns_used is None:
            self.patterns_used = []
        if self.fill_locations is None:
            self.fill_locations = []


class IPerformerAgent(ABC):
    """
    Abstract interface for all performer agents.
    
    Each performer is responsible for generating notes for their
    instrument role, reacting to the shared PerformanceContext.
    
    Implementation Notes:
        - Stage 1: Offline implementations using current procedural methods
        - Stage 2: API-backed implementations calling Copilot/Gemini
        
    The interface is designed to be swappable - you can replace an
    offline DrummerAgent with an API-backed one without changing
    the Conductor or other parts of the system.
    
    Example:
        ```python
        class DrummerAgent(IPerformerAgent):
            @property
            def role(self) -> AgentRole:
                return AgentRole.DRUMS
            
            def perform(self, context, section, personality=None):
                # Generate drum notes...
                return PerformanceResult(notes=notes, ...)
        ```
    """
    
    def __init__(self):
        """Initialize the performer agent."""
        self._personality: Optional['AgentPersonality'] = None
    
    @property
    @abstractmethod
    def role(self) -> AgentRole:
        """
        The musical role this agent fulfills.
        
        Returns:
            AgentRole enum value indicating this agent's function.
            
        Note:
            This property is immutable for the lifetime of the agent.
            To change roles, create a new agent instance.
        """
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        """
        Human-readable name for this agent instance.
        
        Returns:
            A descriptive name like "Jazz Drummer" or "Trap 808 Bassist"
            
        Note:
            This is used for logging, debugging, and display purposes.
            It should be unique enough to distinguish agents of the same role.
        """
        pass
    
    @abstractmethod
    def perform(
        self,
        context: 'PerformanceContext',
        section: 'SongSection',
        personality: Optional['AgentPersonality'] = None
    ) -> PerformanceResult:
        """
        Generate notes for the given section and context.
        
        This is the main entry point for note generation. The agent
        should use the context to make musically-informed decisions
        and generate appropriate notes for their role.
        
        Args:
            context: Shared performance state including tempo, key,
                    chord progression, tension level, and inter-agent
                    communication data (e.g., kick positions for bass).
            section: The song section to generate for, including
                    bar count, section type, and configuration.
            personality: Optional personality override. If None, uses
                        the agent's default personality.
        
        Returns:
            PerformanceResult containing generated notes and metadata.
            
        Implementation Notes:
            - Use context.tension to influence dynamics
            - Use context.fill_opportunity to decide on fills
            - Use context.last_kick_tick (etc.) to lock to other instruments
            - Log decisions in PerformanceResult.decisions_made
        """
        pass
    
    @abstractmethod
    def react_to_cue(
        self,
        cue_type: str,
        context: 'PerformanceContext'
    ) -> List['NoteEvent']:
        """
        React to a performance cue with an immediate response.
        
        Cues are real-time signals from the Conductor that require
        an immediate musical response. Common cues include:
        
        - "fill": Play a fill (drums) or run (melodic)
        - "stop": Immediately stop playing (for breaks)
        - "build": Start building energy (rolls, ascending lines)
        - "drop": Hit hard for a drop moment
        - "accent": Play an accent on the next beat
        
        Args:
            cue_type: String identifier for the cue type.
            context: Current performance context for timing/pitch info.
            
        Returns:
            List of NoteEvent objects for the cue response.
            May be empty if the cue doesn't apply to this agent's role.
            
        Note:
            Unlike perform(), this generates notes for a short time span,
            typically 1-4 beats, not an entire section.
        """
        pass
    
    def set_personality(self, personality: 'AgentPersonality') -> None:
        """
        Update the agent's personality configuration.
        
        Personality affects how the agent generates notes - timing feel,
        velocity dynamics, pattern choices, fill frequency, etc.
        
        Args:
            personality: The new personality configuration to use.
            
        Note:
            This can be called mid-performance to simulate a musician
            "changing their approach" for different sections.
        """
        self._personality = personality
    
    def get_personality(self) -> Optional['AgentPersonality']:
        """
        Get current personality configuration.
        
        Returns:
            The current AgentPersonality, or None if not set.
        """
        return self._personality
